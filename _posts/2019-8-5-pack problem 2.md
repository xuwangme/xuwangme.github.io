---
layout:     post
title:      "[背包问题九讲-2] 完全背包问题"
subtitle:   " \"背包问题九讲-2 完全背包问题\""
date:       2019-8-5 16:21:00
author:     "Xu"
header-img: "img/post-bg-2015.jpg"
catalog: true
tags:
    - Algorithm
---
<script type="text/javascript" async src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-MML-AM_CHTML"> </script>



## [背包问题九讲 - 2]—— 完全背包问题

> 背包问题九讲来自于崔添翼（ACM亚洲区金牌）的个人整理：<https://github.com/tianyicui/pack>，看完之后能够对背包问题的整体认识上一个台阶。
>
> 这里记录其的思路，并少量加上个人理解，同时增加Java代码的实现。

#### 1. 题目：完全背包问题

> 有`N`种物品和一个容量为`V`的背包，每种物品都有**无限件**可用。第`i`种物品的费用是`c[i]`，价值是`w[i]`。求解将哪些物品装入背包可使这些物品的费用总和不超过背包容量，且价值总和最大。
>
> 注：此处的费用`c[i]`即指代的物品在背包中占据的容量，可以理解为`cost`。

#### 2. 基本思路

这个问题非常类似于01背包问题，所不同的是每种物品有无限件。也就是从每种物品的角度考虑，与它相关的策略已并非取或不取两种，而是有取0件、取1件、取2件……等很多种。如果仍然按照解01背包时的思路，令`f[i][v]`表示前`i`种物品恰放入一个容量为`v`的背包的最大权值。仍然可以按照每种物品不同的策略写出状态转移方程，像这样：

> `f[i][v]=max{f[i-1][v-k*c[i]]+k*w[i], 其中0<=k*c[i]<=v，k从0开始递增}`

这跟01背包问题一样有O(VN)个状态需要求解，但求解每个状态的时间已经不是常数了，求解状态`f[i][v]`的时间是`O(v/c[i])`，总的复杂度可以认为是`O(V*sum{(V/c[1])...V/c[N]})`，是比较大的。

将01背包问题的基本思路加以改进，得到了这样一个清晰的方法。这说明01背包问题的方程的确是很重要，可以推及其它类型的背包问题。但我们还是试图改进这个复杂度。

#### 3. 一个简单有效的优化

完全背包问题有一个很简单有效的优化，是这样的：若两件物品`i`、`j`满足`c[i]<=c[j] && w[i]>=w[j]`，则将物品`j`去掉，不用考虑。

这个优化的正确性显然：任何情况下都可将价值小费用高得`j`换成物美价廉的`i`，得到至少不会更差的方案。

对于随机生成的数据，这个方法往往会大大减少物品的件数，从而加快速度。然而这个并不能改善最坏情况的复杂度，因为有可能特别设计的数据可以一件物品也去不掉。这个优化可以简单的O(N^2)地实现，一般都可以承受。

另外，针对背包问题而言，比较不错的一种方法是：首先将费用大于V的物品去掉，然后使用类似计数排序的做法，计算出费用相同的物品中价值最高的是哪个，可以O(V+N)地完成这个优化。这个不太重要的过程就不给出伪代码了。

#### 4. 转化为01背包问题求解

既然01背包问题是最基本的背包问题，那么我们可以考虑把完全背包问题转化为01背包问题来解。最简单的想法是，考虑到第`i`种物品最多选`V/c[i]`件，于是可以把第`i`种物品转化为`V/c[i]`件费用及价值均不变的物品，然后求解这个01背包问题。这样完全没有改进基本思路的时间复杂度，但这毕竟给了我们将完全背包问题转化为01背包问题的思路：将一种物品拆成多件物品。

更高效的转化方法是：把第`i`种物品拆成费用为`c[i]*2^k`、价值为`w[i]*2^k`的若干件物品，其中`k`满足`c[i]*2^k<=V`。这是二进制的思想，因为不管最优策略选几件第`i`种物品，总可以表示成若干个`2^k`件物品的和。这样把每种物品拆成`O(log V/c[i])`件物品，是一个很大的改进。

但我们有更优的O(VN)的算法。

#### 5. O(VN)的算法

这个算法使用一维数组，先看伪代码：

```python
f[0...V] = 0
for i = 1 to N
	for v = c[i] to V
		 f[v] = max(f[v], f[v-c[i]] + w[i])
```

你会发现，这个伪代码与01背包的一维数组的伪代码只有`v`的循环次序不同而已。

为什么这样一改就可行呢？首先想想为什么01背包中要按照`v=V..0`的逆序来循环。这是因为要保证第`i`次循环中的状态`f[i][v]`是由状态`f[i-1][v-c[i]]`递推而来。换句话说，这正是为了保证每件物品只选一次，保证在考虑“选入第`i`件物品”这件策略时，依据的是一个绝对不会已经选入第`i`件物品的子结果`f[i-1][v-c[i]]`。

而现在完全背包的特点恰是每种物品可选无限件，所以在考虑“加选一件第`i`种物品”这种策略时，却正需要一个可能已选入第`i`种物品的子结果`f[i][v-c[i]]`，所以就可以并且必须采用`v=0..V`的顺序循环。这就是这个简单的程序为何成立的道理。

***值得一提的是，上面的伪代码中两层for循环的次序可以颠倒。这个结论有可能会带来算法时间常数上的优化***。

这个算法也可以以另外的思路得出。例如，将基本思路中求解`f[i][v-c[i]]`的二维状态转移方程显式地写出来，代入原方程中，会发现该方程可以等价地变形成这种形式：

> `f[i][v] = max(f[i-1][v], f[i][v-c[i]] + w[i])`

将这个方程用一维数组实现，便得到了上面的伪代码：

最后抽象出处理意见完全背包类物品的过程伪代码：

```python
def completePack(f, c, w)
	for v = c to V
		f[v] = max(f[v], f[v-c]+w)
```



#### 6. 总结

完全背包问题也是一个相当基础的背包问题，它有两个状态转移方程，分别在“基本思路”以及“O(VN)的算法“的小节中给出。希望你能够对这两个状态转移方程都仔细地体会，不仅记住，也要弄明白它们是怎么得出来的，最好能够自己想一种得到这些方程的方法。事实上，对每一道动态规划题目都思考其方程的意义以及如何得来，是加深对动态规划的理解、提高动态规划功力的好方法。



#### 7. Java代码实现：O(VN)算法

```java
class Solution{
    public int solve(int[] w, int[] c, int V){
        int[] f = new int[V+1];//初始化为0
        for (int i = 0; i < c.length; i++){
            completePack(f, w[i], c[i]);
        }
        return f[V];
    }

    private void completePack(int[] f, int w, int c){
        //V = f.length - 1
        for (int v = c; v < f.length; v++){
            f[v] = Math.max(f[v], f[v-c] +w);
        }
    }
}
```

